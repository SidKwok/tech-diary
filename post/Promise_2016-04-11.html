<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="http://cdn.bootcss.com/highlight.js/8.0/styles/tomorrow.min.css"><link rel="stylesheet" href="../css/layout.css"></head><body><div class="content"><h1 id="promise">Promise</h1>
<h2 id="2016-04-11">2016.04.11</h2>
<p>搞了两天的Promise我才略知皮毛，本来想自己实现一个符合Promise/A+规范的模式，但是无奈理解还是不够到位，目前还是没有办法编写出来，再看看我日后的理解，我肯定要写一次的。</p>
<p>首先说Promise是一个什么东东，由定时函数setTimeout说起。举个栗子：</p>
<pre><code class="lang-javascript">var count = 0;

setTimeout(function(){
  count += 1;
  console.log(&quot;step1&quot;, count);
  setTimeout(function(){
    count += 1;
    console.log(&quot;step2&quot;, count);
    setTimeout(function(){
      count += 1;
      console.log(&quot;step3&quot;, count);
    }, 1000)
  }, 1000)
}, 1000)
</code></pre>
<p>我是想通过这个例子来表达一些异步操作的流程。step2要依赖step1的结果，而step3又要依赖step2的结果。而setTimeout函数是异步的，javascript又是运行在单线程的，所以setTimeout是指在一段时间后将一段代码加入到队列里面。所以，如果使用同步的方式，连续写三个setTimeout，会导致结果几乎同时出现，没有达到预期的效果。所以这里就要用嵌套来进行组织。但是，如果嵌套太多，又会导致维护上面的困难，所谓callback hell（其实还有可靠性之类的问题，但是我没能理解，所以先跳过）。</p>
<p>Promise就是用来解决这样的问题的，避免嵌套过深，而且提供完成与失败时候的操作，可以很好地控制自己的代码。开始说Promise1的定义吧。</p>
<p>Promise是定义了将来会发生的事情，包含一个匿名函数参数，其函数里又包含了两个函数参数，resolve和reject.。Promise有三个状态pending(等待)、fulfilled(成功)和rejected(失败)。一个Promise的状态只允许由pending转向fulfilled和rejected，不允许逆向，也不允许fulfilled与rejected的互转。每一个Promise都有一个then方法，then方法有两个参数分别是resolve()和rejected()，字面意思。假设Promise的状态为fulfilled，那么就会执行then中的resolve()，反之亦然。</p>
<pre><code class="lang-javascript">var promise = function(status){
  return new Promise(function(resolve, reject){
    if(status){
      resolve();
    } else {
      reject();
    }
  });
};

promise(true)
  .then(function(){
    console.log(&quot;Yah&quot;);
  }, function(){
    console.log(&quot;shoot&quot;);
  });
</code></pre>
<p>上面的结果明显是输出Yah。首先定义了一个函数，该函数返回了一个Promise实例，然后在实例中定义一系列方法，成功就resolve，不成功就reject。</p>
<p>上面就是Promise的基本用法，但是个人认为Promise最精彩的在于其链式调用。改写一下上面的例子：</p>
<pre><code class="lang-javascript">var promise = function(status, msg){
  return new Promise(function(resolve, reject){
    if(status){
      resolve(msg);
    } else {
      reject(&quot;shoot &quot; + msg);
    }
  });
};

// 先忽略reject的情况
promise(true, &quot;sid&quot;)
  .then(function(msg){
    console.log(msg);
    return msg + &quot; is&quot;;
  })
  .then(function(msg){
    console.log(msg);
    return msg + &quot; hotshot!&quot;;
  })
  .then(function(msg){
    console.log(msg);
  });

  // sid
  // sid is
  // sid is hotshot!
</code></pre>
<p>这个就是链式调用，如果在then中直接返回一个结果的话，这个结果会作为下一个then中的匿名函数的参数传到下一个then中。</p>
<p>那么如果reject又是怎样的呢？注意，由于返回的只是一个结果，所以下一个只会默认传入resolve中，并不会传到reject中。</p>
<pre><code class="lang-javascript">...

promise(true, &quot;sid&quot;)
  .then(function(msg){
    console.log(msg);
    return msg + &quot; is&quot;;
  })
  .then(function(msg){
    console.log(msg);
  }, function(msg){
    console.log(&quot;fail:&quot;, msg);
  });

  // sid
  // sid is
</code></pre>
<p>这里没有输出fail: sid is，因为并不会传递到reject中。所以，单纯地返回一个值其实是不合理的，因为我们需要状态的转换，就是说，一个Promise由pending转到了fulfilled或者rejected，这个Promise已经完成了，但是我们往往需要根据这个Promise1的fulfilled状态继续Promise，那要怎样？返回一个新的Promise呗。重构一下代码。</p>
<pre><code class="lang-javascript">var promise = function(state, msg){
  return new Promise(function(resolve, reject){
    if(state){
      resolve(msg);
    } else {
      reject(&quot;shoot &quot; + msg);
    }
  });
};

promise(true, &quot;sid&quot;)
    .then(function(msg){
      console.log(&quot;success1:&quot;, msg);
      return promise(true, &quot;sid is&quot;);
    })
    .then(function(msg){
      console.log(&quot;success2:&quot;, msg);
      return promise(false, &quot;sid is bad!&quot;);
    })
    .then(function(msg){
      console.log(&quot;success3:&quot;, msg);
    }, function(msg){
      console.log(&quot;fail3:&quot;, msg);
    });

    // success1: sid
    // success2: sid is
    // fail3: sid is bad!
</code></pre>
<p>应该很清楚了，最后那里因为在step2中触发了reject，所以最后也就输出了fail3。这里还说一个catch：</p>
<pre><code class="lang-javascript">.catch(function(){}) &lt;=&gt; .then(undefined, function(){})
</code></pre>
<p>所以说catch只是一个语法糖。</p>
<p>好了，回到上面的定时任务问题，既然then中return1的值可以传到下一个then的resolve中，那就是一切好办啰？来看看：</p>
<pre><code class="lang-javascript">var promise = function(count){
  return new Promise(function(resolve, reject){
    count += 1;
    resolve(count);
  });
};

var count = 0;

promise(count)
  .then(function(count){
    setTimeout(function(){
      console.log(count);
      return count + 1;
    }, 1000);
  })
  .then(function(count){
    setTimeout(function(){
      console.log(count);
      return count + 1;
    }, 1000);
  })
  .then(function(count){
    setTimeout(function(){
      console.log(count);
    }, 1000);
  })

  // 瞬间输出了undefined undefined 1
</code></pre>
<p>咦，和之前说好的不一样啊！再说一次，setTimeout是在一段时间后把代码添加到队列中，典型的异步处理，也就是说，step1定时器中的代码会在1秒后才return，那样子后面的then肯定是接收不到的。那要怎么办呢？这里要使用Promise的一个黑科技，那就是，如果在then中返回的是一个类Promise的对象，那么后面的then会等到前一个then的异步操作完成之后再运行。重构一下代码：</p>
<pre><code class="lang-javascript">var promise = function(cb, ms){
  return new Promise(function(resolve, reject){
    setTimeout(function(){
      cb();
      resolve();
    }, ms);
  });
};

var count = 0;

promise(function(){
  count += 1;
  console.log(&quot;step1&quot;, count);
}, 1000)
  .then(function(){
    return promise(function(){
      count += 1;
      console.log(&quot;step2&quot;, count);
    }, 1000);
  })
  .then(function(){
    return promise(function(){
      count += 1;
      console.log(&quot;step3&quot;, count);
    }, 1000);
  });

// 如愿每秒输出
// step1 1
// step2 2
// step3 3
</code></pre>
<p>就是这样子解决。思路就是，如果需要异步操作按顺序进行，那就将其封装为Promise形式的，一用一个准。</p>
<p>但感觉Promise的厉害之处还不止这些，还需要继续去发掘。</p>
</div><footer><address class="author">Copyright ©<a href="https://github.com/sidkwok">Sid</a></address></footer><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>